../SECTION 4/




../SECTION 4/dia1.fluxos-assincronos.txt



Existem duas formas principais para implementarmos cÃ³digo assÃ­ncrono em JavaScript, usando Callbacks e Promises.

As Callbacks fornecem uma interface com a qual vocÃª pode dizer: â€œe quando terminar de fazer isso, faÃ§a aquiloâ€. 
Podemos entender essa relaÃ§Ã£o fazendo uma analogia ao cenÃ¡rio apresentado anteriormente.
Nesse caso, o Atendente poderia pedir a Pessoa da Cozinha que prepara-se um pedido e ao final 
tocasse um sininho para avisar que o pedido estava pronto. ðŸ”” ðŸ§‘â€ðŸ³


Exemplo 1: Tratando erros de forma sÃ­ncrona.

function dividirNumeros(num1, num2) {
  if (num2 == 0) throw new Error("NÃ£o pode ser feito uma divisÃ£o por zero");

  return num1 / num2;
}

try {
  const resultado = dividirNumeros(2, 1);
  console.log(`resultado: ${resultado}`);
} catch (e) {
  console.log(e.message);
}


Exemplo 2: Tratando erros de forma assÃ­ncrona.

function dividirNumeros(num1, num2) {
  const promise = new Promise((resolve, reject) => {
    if (num2 == 0) 
      reject(new Error("NÃ£o pode ser feito uma divisÃ£o por zero"));

    const resultado = num1 / num2;
    resolve(resultado)
  });

  return promise;
}

dividirNumeros(2, 1)
  .then(result => console.log(`sucesso: ${result}`))
  .catch(err => console.log(`erro: ${err.message}`));


No exemplo 2, note que a funÃ§Ã£o dividirNumeros retorna uma Promise, ou seja, ela promete que vai dividir os nÃºmeros.
 Caso nÃ£o consiga realizar a divisÃ£o, ela rejeita essa promessa, utilizando a funÃ§Ã£o reject. Caso ocorra tudo certo,
  ela resolve a promessa, utilizando a funÃ§Ã£o resolve.
======================
FunÃ§Ãµes Async/Await


Uma funÃ§Ã£o async retorna uma promise, tal como o exemplo abaixo:


function dividirNumeros(num1, num2) {
  const promise = new Promise((resolve, reject) => {
    if (num2 == 0) 
      reject(new Error("NÃ£o pode ser feito uma divisÃ£o por zero"));

    const resultado = num1 / num2;
    resolve(resultado)
  });

  return promise;
}  


Contudo, quando vocÃª chama a funÃ§Ã£o dividirNumeros com o prefixo await, a execuÃ§Ã£o irÃ¡ esperar 
atÃ© que a Promise seja resolvida ou rejeitada.

Precisamos ter bastante atenÃ§Ã£o aqui ðŸ˜³! A funÃ§Ã£o que fizer a chamada da Promise dividirNumeros 
(ou qualquer outra funÃ§Ã£o que retorne uma Promise) deve ser definida como async, conforme o exemplo a seguir:

const doSomething = async () => {
  console.log(await dividirNumeros(2,2));
};


Anota aÃ­ ðŸ–Š: Toda funÃ§Ã£o na qual utilizamos async, passa automaticamente a retornar uma Promise, 
que serÃ¡ rejeitada em caso de erro, e resolvida em caso de sucesso.

Como vocÃª pode ver no exemplo anterior, nosso cÃ³digo fica muito mais simples e legÃ­vel. 
AlÃ©m disso, os maiores benefÃ­cios surgirÃ£o quando o cÃ³digo for muito maior e mais complexo.

As funÃ§Ãµes async podem ser encadeadas facilmente e, alÃ©m disso, seu cÃ³digo serÃ¡ muito mais legÃ­vel, 
se comparado ao uso de Promises. Veja o exemplo a seguir:

const promiseParaFazerAlgumaCoisa = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve('Eu fiz alguma coisa'), 2000)
  })
}

const assistirAlguemFazendoAlgumaCoisa = async () => {
  const something = await promiseParaFazerAlgumaCoisa()
  return something + '\n e Eu vi vocÃª fazendo'
}

const AssistirAlguemAssistindoAlguemFazendoAlgumaCoisa = async () => {
  const something = await assistirAlguemFazendoAlgumaCoisa()
  return something + '\n e Eu tambÃ©m vi vocÃª vendo ele fazendo'
}

AssistirAlguemAssistindoAlguemFazendoAlgumaCoisa().then(res => {
  console.log(res)
})