Práticas comuns de middlewares


A aplicação realiza a validação dos inputs recebidos, e caso eles apresentem algum erro, a API responde 
com um código de erro. Entretanto estes códigos HTTP Status definem o tipo de erro, mas não trazem 
nenhuma informação mais precisa do qual seria o erro. Para resolver isso, pode se enviar na responta 
um json com um objeto por exemplo { message: 'Mensagem de erro personalizada'}. Vamos utilizar como exemplo o middleware validateTeam.

->PREVIOUS
const validateTeam = (req, res, next) => {
  const requiredProperties = ['nome', 'sigla'];
  if (requiredProperties.every((property) => property in req.body)) {
    next(); // Chama o próximo middleware
  } else {
    res.sendStatus(400); // Ou já responde avisando que deu errado
  }
};

=>NOW

const validateTeam = (req, res, next) => {
  const { nome, sigla } = req.body;
  if (!nome) return res.status(400).json({ message: 'O campo "nome" é obrigatório'});
  if (!sigla) return res.status(400).json({ message: 'O campo "sigla" é obrigatório'});
  next();
};


==========================

Passando valores entre middlewares com objeto req

Middlewares também podem modificar os objetos req e res. Essas modificações serão recebidas pelos próximos 
middlewares caso next seja chamado. Geralmente isso é utilizado para propagar informações de um middleware 
para o outro. Isso dá ainda mais flexibilidade para sua composição de middlewares.


==============

Respondendo duas vezes acidentalmente