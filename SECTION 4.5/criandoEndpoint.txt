Criando o endpoint de cadastro de pessoa

No subdiret√≥rio src/routes vamos criar o arquivo src/routes/peopleRoutes.js com o seguinte conte√∫do:

// src/routes/peopleRoutes.js

const express = require('express');

const router = express.Router();

router.post('/', (req, res) => {
  const person = req.body;
  res.status(201).json(person);
});

module.exports = router;



No trecho de c√≥digo acima, estamos criando o endpoint POST /. No corpo da requisi√ß√£o √© esperado 
um arquivo JSON (o mesmo que definimos no teste de integra√ß√£o) e simplesmente retornamos o mesmo 
JSON como resposta, cujo c√≥digo de estado √© igual a 201.



Vamos adicionar o seguinte trecho de c√≥digo para que o express publique nossa rota:


// src/app.js

// const express = require('express');
const peopleRoutes = require('./routes/peopleRoutes');

// const app = express();

// app.use(express.json());

app.use('/people', peopleRoutes);

// module.exports = app;


No trecho de c√≥digo acima:

Adicionamos uma vari√°vel peopleRoutes com o router exportado no arquivo src/routes/peopleRoutes.js;
Adicionamos esse middleware definindo que toda requisi√ß√£o em que o path comece com /people seja encaminhada para ele.

npm test
q falha:

Realizando a comunica√ß√£o com o MySQL

Chegou o t√£o aguardado momento de interagir com o servidor MySQL! üôè

Vamos criar arquivo src/db/peopleDB.js, que tem como responsabilidade agrupar todas as opera√ß√µes SQL relacionadas a tabela people.
 Inicialmente vamos escrever o c√≥digo necess√°rio para inserir uma pessoa no banco de dados, mas ao longo do dia adicionaremos 
 c√≥digo referente a outras opera√ß√µes.

O arquivo deve conter o seguinte conte√∫do:

// src/db/peopleDB.js

const conn = require('./connection');

const insert = (person) => conn.execute(
    `INSERT INTO people 
      (first_name, last_name, email, phone) VALUES (?, ?, ?, ?)`,
    [person.firstName, person.lastName, person.email, person.phone],
  );

module.exports = {
  insert,
};



Inicialmente importamos a conex√£o com o MySQL do nosso outro m√≥dulo e, em seguida, editamos a fun√ß√£o insert
 para receber como par√¢metro um objeto person. Nela escrevemos o c√≥digo referente a um INSERT no banco de dados. 
 Ent√£o, chamamos a fun√ß√£o conn.execute(), a qual recebe dois par√¢metros:

Uma string que cont√©m um INSERT de dados na tabela people. Note que a string foi definida utilizando-se crase para 
possibilitar a quebra de linhas, mas pode-se utilizar as aspas simples ou duplas;

Um array de valores que s√£o extra√≠dos do objeto person;
Vale destacar que no final da string que cont√©m o SQL INSERT, existem quatro sinais de interroga√ß√£o. 
Voc√™ pode estar se perguntando: ‚ÄúEsse SQL n√£o est√° escrito errado?‚Äù ü§î

Esses s√≠mbolos de interroga√ß√£o s√£o chamados de placeholders (ou marcadores, em portugu√™s). Sua fun√ß√£o √© de
 justamente marcar os locais que ser√£o substitu√≠das pelos valores dentro da consulta SQL.

E quais s√£o esses valores que substituir√£o os sinais de interroga√ß√£o? ü§î

S√£o justamente os valores do array que passamos como segundo par√¢metro da fun√ß√£o conn.execute()! A chamada da
 fun√ß√£o conn.execute() com os dois par√¢metros citados √© o que caracteriza uma prepared statement no mysql2.

Podemos pensar nas Prepared Statements como um template ou um molde para consultas SQL que uma aplica√ß√£o deseja
 executar, e que pode ser customizado utilizando vari√°veis de par√¢metros (os placeholders ou marcadores). 
 Isso nos oferece dois grandes benef√≠cios:

As consultas SQL s√≥ necessitam ser preparadas uma √∫nica vez, entretanto podem ser executadas m√∫ltiplas vezes com 
os mesmos par√¢metros ou com par√¢metros diferentes. Quando uma consulta √© preparada, o banco de dados ir√° analisar
, compilar e otimizar a execu√ß√£o da consulta;

Os par√¢metros das prepared statements n√£o devem ser vinculadas diretamente na consulta SQL (utilizando concatena√ß√£o 
de string, por exemplo). O recurso das prepared statements identifica os par√¢metros para o banco de dados, evitando 
que ele erroneamente interprete strings como parte da consulta. Se uma aplica√ß√£o utiliza prepared statements em todas
 as opera√ß√µes que realiza com o banco de dados, essas opera√ß√µes est√£o seguras contra o ataque do tipo SQL injection.

‚ö†Ô∏è Aten√ß√£o: SQL injection √© um tipo de ataque malicioso que uma aplica√ß√£o Web pode sofrer atrav√©s de inje√ß√£o de c√≥digo 
SQL em entradas que n√£o tratam os dados de forma adequada (e.g. formul√°rios, APIs REST, etc). O relat√≥rio anual de 2021 
da Open Web Application Security Project (OWASP) apontou os ataques de inje√ß√£o (categoria do SQL injection) como 
o terceiro maior vetor de ataques maliciosos contra aplica√ß√µes Web. üò®

Na execu√ß√£o dessa prepared statement, os placeholders ser√£o substitu√≠dos pelos valores do array seguindo a 
mesma ordem nos quais eles foram declarados, ou seja, o primeiro placeholder ser√° substitu√≠do pelo primeiro
 valor do array; o segundo placeholder ser√° substitu√≠do pelo valor do segundo valor do array e assim sucessivamente
  at√© o √∫ltimo. Dessa forma, podemos reutilizar esse INSERT apenas passando valores diferentes para o array!

Agora que temos uma prepared statement para inserir uma pessoa, vamos refatorar o endpoint POST / para que ele consiga
 realizar o cadastro de uma pessoa no banco de dados:

// src/routes/peopleRoutes.js

// const express = require('express');
const peopleDB = require('../db/peopleDB');

// const router = express.Router();

router.post('/', async (req, res) => {
  const person = req.body;
  try {
    const [result] = await peopleDB.insert(person);
    res.status(201).json({
      message: `Pessoa cadastrada com sucesso com o id ${result.insertId}` });
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: 'Ocorreu um erro ao cadastrar uma pessoa' });
  }
});
// module.exports = router; 
No c√≥digo acima, importamos o m√≥dulo de src/db/peopleDB.js. No endpoint POST /, criamos 
a vari√°vel person para receber os dados da pessoa a ser cadastrada.

Em seguida, temos um bloco try/catch respons√°vel por responder a requisi√ß√£o. Dentro do bloco try
 √© utilizada a fun√ß√£o insert passando como par√¢metro os dados recebidos na requisi√ß√£o e, por conta 
 do await, aguardamos a inser√ß√£o da pessoa no banco de dados.

Se a inser√ß√£o ocorrer com sucesso, √© retornada uma resposta com o status 201 e com um JSON contendo 
uma mensagem indicando o sucesso da opera√ß√£o.

Em caso de erro, ele √© impresso no terminal via console.log e √© retornada uma resposta com o status
 500 e com um JSON contendo uma mensagem indicando a falha na opera√ß√£o.

Nesse ponto, podemos iniciar a nossa aplica√ß√£o com o comando npm start e realizar uma requisi√ß√£o do 
tipo POST com o Thunder para a nossa API, passando o seguinte JSON:





